
precision mediump float;


attribute vec3 position;
uniform mat4 matrice_vue, matrice_projection, matrice_objet, matrice_objet_inv;
uniform vec3 camera;         //position de la camera dans le référentiel scène
uniform vec2 ks[8];          //vecteurs d'onde
uniform float As[8];         //amplitudes
uniform float ws[8];         //frequences angulaires
uniform float t;             //temps en secondes
uniform float i;             //indice de réfraction
uniform float H;             //profondeur
uniform float visibilite;    //visibilité
uniform vec3 lumiere;        //position de la lumiere

varying vec2 UVfond, UVciel; //Coordonnées de texture du ciel et du fond
varying float Kr, Kv;        //coefficients de réflexion et de réfraction
varying float Il;            //intensité lumineuse
varying vec2 Ncaustique;

void main(void) {
    vec3 dP=vec3(0.,0.,0.);                           //déplacement lié à la vague
    vec3 N=vec3(0.,1.,0.);                            //normale au point traité
    float inSin;                                      //valeur intermédiaire
    for (int i=0; i<8; ++i) {                         //boucle sur les vagues
        inSin=dot(ks[i], position.xz)+t*ws[i];
        dP.y+=0.1*As[i]*sin(inSin);
        N.xz+=As[i]*cos(inSin)*ks[i];                 //normale en une surface : N(x,y)=dM/dx ^ dM/dy
    }
    vec3 P=position+dP;                               //position du point modifiée
    N=normalize(N);
    vec3 C=-(matrice_objet_inv*vec4(camera, 1.)).xyz; //position de la caméra dans le référentiel objet
    vec3 I=normalize(P-C);                            //vecteur incident dans le reférentiel objet

    //rayon réfléchi :
    vec3 R=reflect(I, N);                             //vecteur réfléchi dans le référentiel objet
    float theta=acos(R.x/sqrt(R.x*R.x+R.z*R.z));      //coordonnée sphérique de R : longitude
    float phi=acos(R.y);                              //coordonnée sphérique de R : lattitude
    UVciel=vec2(phi, theta)/6.28;

    //rayon réfracté :
    vec3 Ra=refract(-I,N,i);                         //vecteur directeur du rayon réfracté
//  vec3 Ra=refract(I,N,i);                         //vecteur directeur du rayon réfracté

    float k=H/Ra.y;                                  //distance parcourue par le rayon refracté sous l'eau. Q=P+kR
    UVfond=(P+k*Ra).xz;    

    Kv=smoothstep(0., visibilite,k);                 //coefficient de visibilite. vaut 1 si on ne voit pas le fond    
    Kr=-dot(I, N);                                   //coefficient de Fresnel. vaut 1 pour refraction totale

    //eclairage
    vec3 Ie=normalize(P-lumiere);                      //direction du rayon indicent
    vec3 Re=reflect(Ie, N);                            //rayon reflechi de la lumiere
    Il=0.5+0.6*clamp(pow(0.7*dot(Re,Ie),8.),1., 1.5);  //eclairage ambiant et spéculaire
    
    Ncaustique=N.xz;

    gl_Position = matrice_projection * matrice_vue * matrice_objet * vec4(P, 1.0);
}