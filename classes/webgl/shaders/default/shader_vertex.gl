
precision mediump float;

attribute vec3 position;

uniform vec3 centre, camera;
uniform float scale, hightLight;
uniform mat4 matrice_vue, matrice_projection, matrice_objet;

varying float vI;
varying vec2 vUV;

const vec3 LIGHT=vec3(0.,0.,1.);

void main(void) {
    //compute position
    vec4 pos= matrice_objet * vec4((position*scale)+centre, 1.0);

    //compute refraction
    vec3 incident=normalize(pos.xyz+camera);            //incident vector
    vec3 refracted=refract(incident, position, 1./1.6);      //refracted vector
    vec3 reflected=reflect(incident, position);
    float k=(centre.z-pos.z)/refracted.z;              //M,k so as M=P + k * refracted belongs to (Centrexz)
    vec3 M = ((pos.xyz + k*refracted)-centre)/scale;  
    vUV=vec2(0.5,0.5)+5.*(M.xy*0.5);
    
    //compute lighting
    vI=(0.6+0.5*hightLight);                  //mouseover hightlighting 
    vI*=0.8+0.3*max(dot(position, LIGHT),0.); //diffuse
    vI*=(1.+max(0., 2.*pow(dot(reflected, LIGHT), 6.))); //specular

    
    gl_Position = matrice_projection * matrice_vue * pos;
}